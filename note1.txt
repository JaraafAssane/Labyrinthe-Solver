1. LabyrintheGUI.java â€“ Interface Graphique
Le fichier LabyrintheGUI.java est responsable de lâ€™affichage du labyrinthe et de lâ€™ajout des boutons interactifs permettant de rÃ©soudre le labyrinthe avec DFS ou BFS.

Tout dâ€™abord, la classe hÃ©rite de JPanel, ce qui permet dâ€™utiliser les fonctionnalitÃ©s graphiques de Java pour dessiner le labyrinthe. Lâ€™interface utilise une matrice (char[][] labyrinthe) pour reprÃ©senter les diffÃ©rentes cases du labyrinthe et afficher des couleurs en fonction du contenu des cases (murs, chemins, dÃ©part et sortie).

La mÃ©thode paintComponent(Graphics g) est chargÃ©e de dessiner chaque case du labyrinthe sur lâ€™interface. Elle parcourt toutes les cellules et applique une couleur spÃ©cifique selon le type de case :

Mur (#) â†’ Noir
Chemin libre (=) â†’ Blanc
DÃ©part (S) â†’ Bleu
Sortie (E) â†’ Rouge
Solution trouvÃ©e (+) â†’ Jaune
Ensuite, la classe contient une mÃ©thode statique afficherLabyrinthe(), qui crÃ©e une fenÃªtre graphique (JFrame) et y ajoute le labyrinthe ainsi que des boutons interactifs. Deux boutons sont disponibles :

Un bouton DFS, qui lance lâ€™algorithme de recherche en profondeur et affiche le chemin trouvÃ©.
Un bouton BFS, qui lance la recherche en largeur et met Ã  jour lâ€™interface avec la solution.
Lorsque lâ€™utilisateur clique sur un bouton, lâ€™algorithme correspondant est exÃ©cutÃ©, et le labyrinthe est mis Ã  jour dynamiquement pour afficher la solution trouvÃ©e. Un label d'affichage des performances permet aussi de voir le temps dâ€™exÃ©cution des algorithmes.

En rÃ©sumÃ©, ce fichier permet de visualiser le labyrinthe, d'exÃ©cuter DFS ou BFS via des boutons, et de comparer leurs performances en temps rÃ©el.

ğŸ“Œ 2. SolveurBFS.java â€“ Algorithme BFS
Le fichier SolveurBFS.java contient lâ€™implÃ©mentation de lâ€™algorithme de recherche en largeur (BFS), qui est utilisÃ© pour trouver le chemin le plus court dans le labyrinthe.

Tout dâ€™abord, la classe utilise une file (Queue), qui suit une logique FIFO (First In, First Out). Cela signifie que lâ€™algorithme explore les cases les plus proches avant dâ€™aller plus loin, garantissant ainsi que la premiÃ¨re solution trouvÃ©e est la plus courte possible.

Le constructeur de la classe initialise trois Ã©lÃ©ments principaux :

Un tableau visite[][], pour suivre les cases dÃ©jÃ  explorÃ©es et Ã©viter les boucles infinies.
Un tableau solution[][], qui reprÃ©sente le labyrinthe avec la solution trouvÃ©e.
Une variable executionTime, qui stocke la durÃ©e dâ€™exÃ©cution de lâ€™algorithme pour mesurer sa performance.
Lorsque lâ€™utilisateur exÃ©cute la mÃ©thode resoudre(), lâ€™algorithme commence Ã  partir du point de dÃ©part (S) et ajoute cette position dans la file dâ€™attente. Ensuite, une boucle while explore les cases voisines dans lâ€™ordre suivant :

Droite
Bas
Gauche
Haut
Chaque nouvelle case visitÃ©e est ajoutÃ©e Ã  la file dâ€™attente, marquÃ©e comme explorÃ©e, et enregistrÃ©e dans une table de correspondance (HashMap parents) qui permet de retracer le chemin une fois la sortie atteinte.

DÃ¨s que lâ€™algorithme atteint la sortie (E), il remonte le chemin parcouru en suivant les parents de chaque case, et marque le chemin optimal avec +. Ce chemin est ensuite retournÃ© et affichÃ© dans lâ€™interface graphique.

En rÃ©sumÃ©, ce fichier implÃ©mente lâ€™algorithme BFS, qui explore le labyrinthe de maniÃ¨re mÃ©thodique pour toujours trouver le chemin le plus court.

ğŸ“Œ 3. SolveurDFS.java â€“ Algorithme DFS
Le fichier SolveurDFS.java contient lâ€™implÃ©mentation de lâ€™algorithme de recherche en profondeur (DFS), qui explore un chemin jusquâ€™au bout avant de revenir en arriÃ¨re.

Contrairement Ã  BFS, DFS utilise une rÃ©cursion pour parcourir le labyrinthe. Cela signifie quâ€™il peut parfois trouver un chemin plus long que BFS, car il ne cherche pas Ã  optimiser la distance.

Le constructeur initialise trois Ã©lÃ©ments :

Un tableau visite[][], qui suit les cases dÃ©jÃ  explorÃ©es pour Ã©viter les boucles.
Un tableau solution[][], qui reprÃ©sente la solution trouvÃ©e.
Une liste cheminOptimal, qui stocke le meilleur chemin trouvÃ© jusquâ€™Ã  prÃ©sent.
Lorsque lâ€™utilisateur exÃ©cute la mÃ©thode resoudre(), lâ€™algorithme dÃ©marre Ã  partir du point de dÃ©part (S) et appelle rÃ©cursivement la mÃ©thode dfs(), qui fonctionne de la maniÃ¨re suivante :

Si la case est un mur (#) ou dÃ©jÃ  visitÃ©e, on retourne false.
Si la case est la sortie (E), on retourne true, ce qui signifie quâ€™on a trouvÃ© un chemin valide.
Sinon, on explore les quatre directions possibles (droite, bas, gauche, haut) une par une.
DÃ¨s quâ€™une direction permet dâ€™atteindre la sortie, lâ€™algorithme marque la case actuelle comme une partie du chemin (+). Si aucune des directions ne mÃ¨ne Ã  la sortie, lâ€™algorithme revient en arriÃ¨re et essaie une autre direction.

Comme DFS peut explorer plusieurs chemins avant de trouver la sortie, il stocke le premier chemin trouvÃ© et l'affiche comme solution.

En rÃ©sumÃ©, ce fichier implÃ©mente DFS, une recherche en profondeur qui explore un chemin jusquâ€™au bout avant de revenir en arriÃ¨re, ce qui peut parfois mener Ã  des chemins plus longs.

ğŸ“Œ 4. Labyrinthe.java â€“ Gestion du Labyrinthe
Le fichier Labyrinthe.java est utilisÃ© pour stocker et charger le labyrinthe depuis un fichier texte.

Tout dâ€™abord, la classe contient une matrice char[][] labyrinthe, qui reprÃ©sente chaque case du labyrinthe. Les symboles utilisÃ©s sont :

# pour les murs
= pour les chemins libres
S pour le point de dÃ©part
E pour la sortie
Le constructeur de la classe propose deux faÃ§ons de charger un labyrinthe :

Depuis un fichier texte (labyrinthe.txt), en lisant chaque ligne et en la convertissant en tableau de caractÃ¨res.
Depuis un gÃ©nÃ©rateur alÃ©atoire, qui construit un labyrinthe avec des murs et un chemin alÃ©atoire entre S et E.
Une fois le labyrinthe chargÃ©, la classe fournit plusieurs mÃ©thodes pour accÃ©der aux coordonnÃ©es de dÃ©part et de sortie.

En rÃ©sumÃ©, ce fichier est la base du projet, car il gÃ¨re la structure et le chargement du labyrinthe en mÃ©moire.

ğŸ“Œ 5. Main.java â€“ Programme Principal
Le fichier Main.java est le point dâ€™entrÃ©e du programme.

Lorsque le programme dÃ©marre, il affiche un menu interactif permettant de :

GÃ©nÃ©rer un labyrinthe alÃ©atoire
Charger un labyrinthe depuis un fichier
Quitter le programme
Une fois le labyrinthe chargÃ©, le programme crÃ©e deux solveurs :

Un solveur DFS (SolveurDFS)
Un solveur BFS (SolveurBFS)
Ensuite, il affiche lâ€™interface graphique avec le labyrinthe, permettant Ã  lâ€™utilisateur dâ€™exÃ©cuter DFS ou BFS en cliquant sur les boutons.

En rÃ©sumÃ©, ce fichier permet Ã  lâ€™utilisateur de choisir son labyrinthe, dâ€™exÃ©cuter DFS ou BFS, et de voir les rÃ©sultats dans lâ€™interface graphique.

ğŸ“Œ Besoin dâ€™ajouter encore plus de dÃ©tails ? ğŸš€






Vous avez ditÂ :
avec des termes de developpeur
ChatGPT a ditÂ :
ğŸ“Œ Explication dÃ©taillÃ©e du code avec un langage technique pour dÃ©veloppeur
Voici une description plus technique et orientÃ©e dÃ©veloppeur du projet, expliquant chaque fichier en suivant la structure du code.

ğŸ“Œ 1. LabyrintheGUI.java â€“ Interface Graphique avec Swing
Le fichier LabyrintheGUI.java est une implÃ©mentation basÃ©e sur Swing, servant Ã  rendre le labyrinthe en mode graphique et afficher dynamiquement les solutions des algorithmes DFS et BFS.

Structure principale du fichier :
Extends JPanel : Permet dâ€™utiliser les capacitÃ©s graphiques de Swing pour dessiner la grille du labyrinthe.
MÃ©thode paintComponent(Graphics g) : Override de la mÃ©thode Swing permettant de dessiner chaque cellule du labyrinthe en fonction de son Ã©tat (mur, chemin, dÃ©part, arrivÃ©e, solution).
MÃ©thode statique afficherLabyrinthe() :
Initialise une JFrame pour l'affichage.
Ajoute des JButton pour exÃ©cuter DFS et BFS, avec des ActionListener pour mettre Ã  jour lâ€™UI aprÃ¨s lâ€™exÃ©cution de lâ€™algorithme.
IntÃ¨gre un JLabel pour afficher les performances des algorithmes en millisecondes.
Points techniques clÃ©s :
Redimensionnement dynamique (setPreferredSize()) pour sâ€™adapter Ã  la taille du labyrinthe.
Gestion dâ€™Ã©vÃ©nements (addActionListener()) pour exÃ©cuter les solveurs et rafraÃ®chir lâ€™affichage (repaint()).
Utilisation du Grid-based rendering pour modÃ©liser chaque cellule avec des couleurs spÃ©cifiques.
ğŸ“Œ Ce fichier assure la partie front-end du projet, en permettant d'afficher et de visualiser les solutions gÃ©nÃ©rÃ©es par DFS et BFS en temps rÃ©el.

ğŸ“Œ 2. SolveurBFS.java â€“ ImplÃ©mentation de la recherche en largeur
Ce fichier implÃ©mente lâ€™algorithme Breadth-First Search (BFS) pour explorer le labyrinthe de maniÃ¨re exhaustive et garantir le chemin le plus court.

Structure principale du fichier :
Utilisation dâ€™une Queue<int[]> (FIFO) pour gÃ©rer les nÅ“uds Ã  explorer dans lâ€™ordre dâ€™arrivÃ©e.
Tableau visite[][] pour Ã©viter de revisiter les cases dÃ©jÃ  traitÃ©es.
Table de hachage HashMap<String, int[]> pour stocker le chemin dâ€™origine de chaque case et reconstruire le chemin optimal aprÃ¨s lâ€™exÃ©cution.
Boucle principale while (!queue.isEmpty()) :
DÃ©file un Ã©lÃ©ment, explore ses voisins (droite, bas, gauche, haut).
VÃ©rifie les contraintes (hors limite, mur, dÃ©jÃ  visitÃ©).
Stocke le parent de chaque cellule pour reconstruire le chemin une fois la sortie atteinte.
Reconstruction du chemin optimal (backtracking) :
Suit les parents stockÃ©s dans HashMap depuis la sortie (E) jusquâ€™au dÃ©part (S).
Marque le chemin final avec +.


ğŸ“Œ 3. SolveurDFS.java â€“ ImplÃ©mentation de la recherche en profondeur
Ce fichier implÃ©mente Depth-First Search (DFS) en mode rÃ©cursif, permettant dâ€™explorer un chemin jusquâ€™au bout avant de revenir en arriÃ¨re (backtracking).

Structure principale du fichier :
Utilisation de la rÃ©cursion (dfs(x, y)) pour avancer dans le labyrinthe jusquâ€™Ã  un cul-de-sac ou la sortie.
Stockage des cases visitÃ©es (visite[][]) pour Ã©viter de boucler indÃ©finiment.
Exploration en 4 directions (droite, bas, gauche, haut) pour naviguer dans la matrice du labyrinthe.
Si la sortie est atteinte (E), le chemin est validÃ© et sauvegardÃ©.
Backtracking :
Si un chemin ne mÃ¨ne pas Ã  la sortie, lâ€™algorithme revient en arriÃ¨re et explore une autre direction.
ProblÃ¨mes et amÃ©liorations techniques :
DFS nâ€™est pas optimal : Il peut trouver un chemin plus long que BFS.
Gestion de la profondeur rÃ©cursive : Risque de StackOverflowError sur un labyrinthe trÃ¨s complexe.
Stockage du meilleur chemin (cheminOptimal) pour Ã©viter dâ€™Ã©craser des solutions valides par dâ€™autres sous-optimales.
ğŸ“Œ Ce fichier met en place DFS en version rÃ©cursive, permettant une exploration complÃ¨te du labyrinthe, bien que non optimale en termes de distance parcourue.

ğŸ“Œ 4. Labyrinthe.java â€“ Gestion des structures de donnÃ©es du labyrinthe
Ce fichier est le cÅ“ur de la modÃ©lisation du labyrinthe, gÃ©rant le stockage, le chargement et lâ€™accÃ¨s aux donnÃ©es.

Structure principale du fichier :
Stockage en char[][] labyrinthe
Constructeur basÃ© sur un fichier texte (BufferedReader)
Lit le fichier ligne par ligne et stocke le labyrinthe sous forme de tableau de caractÃ¨res.
MÃ©thodes d'accÃ¨s aux donnÃ©es (getStartX(), getEndY()) pour faciliter lâ€™interaction avec les solveurs.
PossibilitÃ© dâ€™instancier un labyrinthe alÃ©atoire (LabyrintheGenerateur.java)
GÃ©nÃ©ration alÃ©atoire des murs (#) et chemins (=).
Placement automatique du dÃ©part (S) et de la sortie (E).
ğŸ“Œ Ce fichier assure la gestion de la structure de donnÃ©es du labyrinthe, permettant aux solveurs de lâ€™exploiter sans se soucier du format source.

ğŸ“Œ 5. Main.java â€“ Programme Principal
Ce fichier est le point dâ€™entrÃ©e du projet, gÃ©rant lâ€™interaction avec lâ€™utilisateur et lâ€™exÃ©cution des algorithmes.

Structure principale du fichier :
Menu interactif (Scanner)
Permet Ã  lâ€™utilisateur de choisir entre un labyrinthe alÃ©atoire ou un fichier texte.
GÃ¨re la logique de boucle pour permettre de jouer plusieurs fois.
Instanciation des solveurs (SolveurDFS et SolveurBFS)
Appel de LabyrintheGUI.afficherLabyrinthe()
Affichage de lâ€™interface graphique.
Interaction utilisateur via les boutons pour exÃ©cuter DFS ou BFS.
ğŸ“Œ Ce fichier orchestre lâ€™ensemble du projet en initialisant le labyrinthe, les solveurs et lâ€™interface graphique, offrant une expÃ©rience utilisateur fluide et interactive.

ğŸ“Œ Conclusion
Ce projet met en Å“uvre deux algorithmes de recherche sur graphes (DFS et BFS) dans un environnement en grille, en utilisant Java et Swing pour offrir une expÃ©rience visuelle interactive.

ğŸ“Œ Points techniques majeurs :
âœ”ï¸ Exploration du graphe via une structure matricielle char[][].
âœ”ï¸ Utilisation de Queue (BFS) et de rÃ©cursion (DFS) pour explorer le labyrinthe.
âœ”ï¸ Gestion dâ€™une interface graphique dynamique avec Swing.
âœ”ï¸ Comparaison de la complexitÃ© et des performances des deux algorithmes.

âœ… PrÃªt pour la prÃ©sentation ? Ou veux-tu encore plus de dÃ©tails ?





































---


---

#### 1. LabyrintheGUI.java â€“ Une Interface Graphique Dynamique

Le fichier LabyrintheGUI.java est le cÅ“ur visuel du projet, offrant une reprÃ©sentation graphique claire et interactive du labyrinthe. Il affiche une grille oÃ¹ chaque case est colorÃ©e selon son rÃ´le : les murs apparaissent en noir, les chemins libres en blanc, le point de dÃ©part en bleu, la sortie en rouge, et le chemin solution en jaune. Cette palette de couleurs rend le labyrinthe intuitif Ã  comprendre, mÃªme pour un novice. Lâ€™interface est construite avec une fenÃªtre principale contenant le labyrinthe, accompagnÃ©e de deux boutons interactifs : lâ€™un pour lancer DFS, lâ€™autre pour BFS. Lorsquâ€™un utilisateur clique sur un bouton, lâ€™algorithme correspondant sâ€™exÃ©cute, et le labyrinthe se met Ã  jour instantanÃ©ment pour montrer le chemin trouvÃ©, avec un label indiquant le temps dâ€™exÃ©cution en millisecondes. Cette mise Ã  jour dynamique est essentielle pour visualiser les diffÃ©rences entre les deux approches algorithmiques. 

DÃ©tails techniques :

HÃ©ritage : Ã‰tend JPanel pour exploiter les outils graphiques de Swing.
Dessin : La mÃ©thode paintComponent(Graphics g) parcourt une matrice char[][] labyrinthe et dessine chaque case avec une couleur spÃ©cifique :
# (mur) â†’ Noir
= (chemin) â†’ Blanc
S (dÃ©part) â†’ Bleu
E (sortie) â†’ Rouge
+ (solution) â†’ Jaune
InteractivitÃ© : La mÃ©thode statique afficherLabyrinthe() crÃ©e une JFrame, ajoute deux JButton (DFS et BFS) avec des ActionListener, et un JLabel pour afficher le temps dâ€™exÃ©cution.
Mise Ã  jour : AprÃ¨s chaque clic, lâ€™algorithme sâ€™exÃ©cute, et repaint() rafraÃ®chit lâ€™affichage pour montrer le chemin trouvÃ©.
RÃ©sultat : Une interface visuelle qui permet de voir le labyrinthe se rÃ©soudre en temps rÃ©el, avec un chrono pour comparer les performances.
---

#### 2. SolveurBFS.java â€“ Recherche en Largeur pour le Chemin Optimal

SolveurBFS.java implÃ©mente la recherche en largeur (BFS), un algorithme conÃ§u pour trouver le chemin le plus court entre le dÃ©part et la sortie du labyrinthe. Son principe repose sur une exploration mÃ©thodique : il commence au point de dÃ©part et examine les cases voisines niveau par niveau, sâ€™assurant ainsi que la premiÃ¨re solution trouvÃ©e est la plus courte possible. Pour ce faire, il utilise une file qui suit une logique "premier entrÃ©, premier sorti", garantissant que les cases les plus proches sont explorÃ©es en prioritÃ©. Lâ€™algorithme garde une trace des cases visitÃ©es pour Ã©viter les boucles infinies et stocke les relations entre chaque case et son "parent" pour reconstruire le chemin une fois la sortie atteinte. Lorsquâ€™il trouve la sortie, il retrace le parcours optimal et le marque dans une matrice dÃ©diÃ©e, prÃªte Ã  Ãªtre affichÃ©e dans lâ€™interface graphique. De plus, il mesure le temps dâ€™exÃ©cution et compte le nombre de cases explorÃ©es, offrant ainsi des donnÃ©es pour analyser sa performance. Une amÃ©lioration possible serait dâ€™introduire une variante comme lâ€™algorithme A*, qui utilise des heuristiques pour accÃ©lÃ©rer la recherche, ou dâ€™ajouter un suivi des distances pour chaque case explorÃ©e. BFS brille dans ce projet par sa capacitÃ© Ã  garantir une solution optimale, ce qui le rend idÃ©al pour les labyrinthes oÃ¹ la longueur du chemin est une prioritÃ©.

DÃ©tails techniques :

Structure : Utilise une Queue<int[]> (FIFO) pour explorer les cases dans lâ€™ordre de proximitÃ©.
Outils :
visite[][] : Tableau boolean pour Ã©viter les boucles.
solution[][] : Matrice pour stocker le chemin final.
HashMap<String, int[]> : Retrace le chemin via les "parents" de chaque case.
Logique :
Part du S et ajoute les voisins (droite, bas, gauche, haut) dans la file.
Explore jusquâ€™Ã  atteindre E, puis reconstruit le chemin avec + en suivant les parents
---

#### 3. SolveurDFS.java â€“ Recherche en Profondeur avec Exploration RÃ©cursive

SolveurDFS.java met en Å“uvre la recherche en profondeur (DFS), une approche qui plonge dans un chemin jusquâ€™Ã  son terme avant de revenir en arriÃ¨re si nÃ©cessaire. Contrairement Ã  BFS, DFS ne cherche pas lâ€™optimalitÃ© mais explore un parcours complet avant dâ€™essayer une autre direction, ce qui peut parfois conduire Ã  des chemins plus longs. Cet algorithme fonctionne de maniÃ¨re rÃ©cursive : il part du point de dÃ©part, marque chaque case visitÃ©e, et avance dans une direction (droite, bas, gauche, haut) jusquâ€™Ã  rencontrer un mur, une impasse, ou la sortie. Sâ€™il atteint la sortie, il sauvegarde le chemin trouvÃ© ; sinon, il revient en arriÃ¨re pour tester une autre option, une technique appelÃ©e backtracking. Comme BFS, il suit les cases explorÃ©es pour Ã©viter les cycles et mesure le temps dâ€™exÃ©cution ainsi que le nombre de nÅ“uds visitÃ©s. Cependant, sa nature rÃ©cursive le rend vulnÃ©rable Ã  des problÃ¨mes comme une pile dâ€™appels trop profonde dans des labyrinthes trÃ¨s grands, ce qui pourrait Ãªtre rÃ©solu en passant Ã  une version itÃ©rative avec une pile explicite. Pour aller plus loin, on pourrait comparer plusieurs chemins trouvÃ©s par DFS et sÃ©lectionner le plus court. En rÃ©sumÃ©, DFS offre une solution rapide et complÃ¨te, mais pas forcÃ©ment optimale, ce qui en fait un contraste intÃ©ressant avec BFS dans ce projet.

DÃ©tails techniques :

Structure : Fonctionne avec une mÃ©thode rÃ©cursive dfs(x, y).
Outils :
visite[][] : Suit les cases explorÃ©es.
solution[][] : Enregistre le chemin trouvÃ©.
Logique :
Avance dans une direction (droite, bas, gauche, haut) jusquâ€™Ã  un mur ou la sortie.
Si E est atteint, marque le chemin avec +. Sinon, revient en arriÃ¨re (backtracking).

---

#### 4. Labyrinthe.java â€“ Gestion de la Structure de DonnÃ©es

Labyrinthe.java est la fondation du projet, responsable de la crÃ©ation et de la gestion du labyrinthe lui-mÃªme. Il stocke la grille sous forme dâ€™une matrice de caractÃ¨res, oÃ¹ chaque symbole a une signification prÃ©cise : les murs sont reprÃ©sentÃ©s par des diÃ¨ses, les chemins libres par des signes Ã©gal, le dÃ©part par un "S", et la sortie par un "E". Ce fichier propose deux faÃ§ons de construire un labyrinthe : soit en le chargeant depuis un fichier texte, oÃ¹ chaque ligne est lue et convertie en tableau de caractÃ¨res, soit en utilisant une gÃ©nÃ©ration alÃ©atoire qui place des murs et des chemins viables entre le dÃ©part et la sortie. Une fois le labyrinthe prÃªt, il identifie automatiquement les coordonnÃ©es du dÃ©part et de la sortie pour les fournir aux algorithmes de rÃ©solution. Cette modularitÃ© permet une grande flexibilitÃ©, car lâ€™utilisateur peut tester ses propres labyrinthes ou laisser le programme en crÃ©er un nouveau Ã  chaque partie.

DÃ©tails techniques :

Structure : Utilise une matrice char[][] labyrinthe avec #, =, S, et E.
Chargement :
Lit un fichier texte (labyrinthe.txt) via BufferedReader.
Ou gÃ©nÃ¨re un labyrinthe alÃ©atoire avec des murs et un chemin viable.
AccÃ¨s : Fournit des mÃ©thodes comme getStartX() pour localiser S et E.

---

#### 5. Main.java â€“ Orchestration et Interaction Utilisateur

Main.java sert de point dâ€™entrÃ©e au programme, orchestrant lâ€™ensemble des composants pour offrir une expÃ©rience fluide Ã  lâ€™utilisateur. Lorsquâ€™il dÃ©marre, il affiche un menu simple mais efficace : lâ€™utilisateur peut choisir de gÃ©nÃ©rer un labyrinthe alÃ©atoire, charger un labyrinthe depuis un fichier texte en entrant son nom, ou quitter le programme. Selon le choix, un labyrinthe est crÃ©Ã© ou chargÃ©, puis deux instances des solveurs (DFS et BFS) sont prÃ©parÃ©es avec ce labyrinthe comme base. Ensuite, lâ€™interface graphique est lancÃ©e, affichant le labyrinthe avec ses boutons interactifs, prÃªte Ã  rÃ©pondre aux clics de lâ€™utilisateur. Une fois la partie terminÃ©e, le programme demande si lâ€™utilisateur souhaite rejouer, permettant ainsi plusieurs sessions sans relancer lâ€™application. Cette boucle dâ€™interaction est intuitive et conviviale, rendant le projet accessible mÃªme Ã  ceux qui ne codent pas. Pour enrichir cette partie, on pourrait ajouter une option pour sauvegarder les solutions dans un fichier ou proposer un mode console oÃ¹ les chemins sont affichÃ©s textuellement sans interface graphique. Main.java agit comme le chef dâ€™orchestre, reliant la logique des algorithmes Ã  lâ€™expÃ©rience visuelle, et offrant une porte dâ€™entrÃ©e accueillante au projet.

---

